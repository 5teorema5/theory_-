<h2>Уд (критические темы прошлого семестра)</h2>

<details>
<summary><h3>1. Указатели и ссылки – сходства, отличия, зачем нужны.</h3></summary>

Указатели и ссылки предоставляют косвенный доступ к данным (переменным, массивам, структурам и тп), т.е. позволяют работать с объектами (которые могут быть а) очень большими, б) зарыты в памяти компьютера), не копируя их напрямую.

Указатели:

  * Хранят адрес объекта в памяти.
  * Могут быть null, указывая на отсутствие объекта.
  * Могут быть перенаправлены на другой объект после инициализации.
  * Требуют ручного управления памятью (выделение и освобождение!).
    
Ссылки:

  * Являются псевдонимами для существующих объектов.
  * Не могут быть null (не может быть ссылки на несуществующий элемент).
  * Не могут быть перенаправлены после инициализации.
  * Автоматически управляются системой (не требуют ручного выделения/освобождения памяти).

Зачем нужны:

* Передача больших объектов в функции: Используя указатели и ссылки, мы избегаем ненужного копирования, что повышает производительность.
* Динамическое выделение памяти: Позволяют создавать объекты в куче.
* Полиморфизм: Позволяют работать с объектами разных типов через общий интерфейс.

</details>

<details>
<summary><h3>2. Сложность алгоритма. Сортировка за О(N 2), O(NlogN).</h3></summary>

Любой алгоритм можно оценить по уровню сложности исходя из пропорциональности выполнения операции и количества элементов. 

O(N^2): 
  * Алгоритмы с квадратичной сложностью выполняют операции пропорционально квадрату количества элементов. 
  * Примеры: сортировка пузырьком, сортировка вставками, сортировка выбором.
  * Подходят для небольших наборов данных.

O(NlogN):
  * Алгоритмы с логарифмической сложностью выполняют операции пропорционально N*log(N).
  * Примеры: быстрая сортировка, сортировка методом Хоара, сортировка расчёсткой.
  * Более эффективны для больших наборов данных.
  * 
Важно помнить, что в разных ситуациях нужно применять разные алгоритмы разной сложности. Нет смысла сортировать учеников одной группы по баллам, используя метод рассчёски.

</details>

<details>
<summary><h3>3. Сложность алгоритма. Поиск числа в массиве, доступ к произвольному элементу.</h3></summary>

Сложность алгоритмов смотри предыдущий вопрос.

Поиск в отсортированном массиве:

  * Бинарный поиск: O(logN) - эффективен благодаря делению массива пополам на каждом шаге. А поскольку массив отсортирован, то с одно стороны элементы больше (или равны) искомому, а с другой стороны -- меньше (или равны).

Поиск в неотсортированном массиве:

  * Линейный поиск: O(N) - необходимо проверить каждый элемент.

Доступ к произвольному элементу массива: 
  * O(1) - прямой доступ по индексу.

</details>

<details>
<summary><h3>4. Модель памяти .flat. Правила работы стека локальных переменных. Правила работы кучи.</h3></summary>

В этой модели все сегменты памяти (код, данные, стек, куча) располагаются в едином адресном пространстве.
    * Упрощает управление памятью и доступ к данным.

Модель памяти .flat представляет собой сегменты памятиЮ которые располагаются в едином адресном пространстве:
	Глобальные переменные → текст программы (машинный код) → стек локальных 	переменных → куча. 
В стеке локальных переменных хранятся указатели на переменные, объявленные, но не инициализированные данные, оболочка объектов. В куче хранятся сами данные, на которые указываю переменные из стека локальных переменных. Именно в ней хранятся элементы массивов, других структур. Когда мы обращается к переменной, мы обращается в стеку локальных переменных, откуда мы перенаправляемся на адрес в куче, по которому «живёт» наш объект.  

Стек:

  * Используется для хранения локальных переменных и информации о вызовах функций.
  * Автоматически управляется системой (выделение и освобождение памяти).

Куча:
  * Область памяти для динамического выделения.
  * Программист сам управляет памятью (выделение с помощью new, освобождение с помощью delete).
  * Позволяет создавать объекты произвольного размера и времени жизни.
  * Важно помнить, что кучу необходимо очищать, нельзя удалять указатели на объекты, не удаляя данные по этим ссылкам. Это приводит к утечке данных — не приятно.

</details>

<h2>Хор (основные механики ООП и STL)</h2>

<details>
<summary><h3>1. Инкапсуляция. Что это такое и зачем нужно.</h3>></summary>

Если писать объекты с отрытым доступом, то может возникнуть ряд проблем:
1) вызывающий код может всё сломать;
2) вызывающий код обязан знать внутреннюю логику, как минимум вызывать init и finalize, хотя это внутренне дело объекта;
3) вызывающий код зачем то должен знать объект со всеми его полями, хотя логически хочет видеть просто объект.

Для решения эти проблем используют инкапсуляцию — скрытие данных объекта. С помощью инкапсуляции мы сами регулируем то, как именно пользователь будет обращаться к объекту, ставим ему чёткие рамки.

Теперь:
1) Вызывающий код не может ничего сломать, по крайней мере, очевидным образом;
2) Аналоги init и finalize срабатывают сами в нужный момент;
3) Вызывающий код не должен знать про изнанку реализации;
4) Код чище и читаемее.

</details>

<details>
<summary><h3>2. Наследование. Что это такое и зачем нужно.</h3></summary>

Общая идея наследования заключается в выделении общего поведения у разных классов в отдельный класс-предок. То есть всё наследование — это про то, как не писать повторно один и тот же код для «почти одинаковых» сущностей.

Пример, мы хотим работать с системой зоопарка. Для этого мы можем написать классы под каждого сотрудника, где будут прописаны его обязанности, данные, зп,.. Нам так же нужен класс для каждого животного в котором будут прописаны все особенности… Ну это капец! Мы лучше создадим Два класса-родителя Humans и Animals, в котором пропишем все общие черты людей/животных, а дальше будем создавать классы наследники, для которых нам останется написать только особенности каждой зверушки.

</details>

<details>
<summary><h3>3. Полиморфизм – концепция и примеры.</h3></summary>

Суть полиморфизма заключается в том, что некоторая сущность может вести себя по-разному в разных ситуациях. Сущность, которая обладает этим свойством, сама подстраивается к этим ситуациям, и не заставляет крутиться весь мир вокруг неё.

```C++
#include <iostream>
...
void funk(char a) {
  std::cout << "This char" << '\n';
}

void funk(int a) {
  std::cout << "This int" << '\n';
}

void funk(double a, unsigned int b) {
  std::cout << "This double & unsigned int" << '\n';
}
...
int main() {
  funk('A');
  funk('7');
  funk(3.14, 3);
  return 0;
}
```

</details>

<details>
<summary><h3>4. Конструкторы, деструкторы. Когда вызываются, зачем нужны.</h3></summary>

Каждый класс необходимо сначая создать, в конце работы с ним необходимо удалить - чтобы лишнюю память не занимал. За это и отвечают конструкторы и деструкторы.

```C++
...
class stack {
private:
  int size;
public:
  //конструктор создаёт стек нулевого размера
  stack() {};
  //конструктор создаёт стэк нужного размера
  stack(int size) {};
  //деструктор удаляет стек
  ~stack();
}
...
```

 * Конструктор -- это специальный метод, который, очевидно, вызывают перед началом работы с объектор данного класса (при его создании). Используется для инициализации полей объекта, причём с помощью полиморфизма можно сделать несколько конструкторов, которые будут создавать объект по-разному.
 * Деструктор -- специальный метод, который, опять же очевидно, вызывается в конце работы с объектом класса (при удалении объекта). Можно, конечно же, не вызвать, после окончания работы с программой автоматически вызовятся все деструкторы всех объектов всех классов, которые были использованы. Этот метод используется для освобождения ресурсов, выделенных объектом.

</details>

<details>
<summary><h3>5. Виртуальные поля и методы. Пояснить на примере, как работает механика виртуальности.</h3></summary>

Иногда в родительском классе можно сказать только "здесь должен быть вот такой метод", но нельзя написать его реализацию.

 * заведомо предполагается, что классы будут унаследованы;
 * метод для них всех нужен, можно в общем виде сказатьб, что метод должен делать;
 * реализация будет кардинально разной в разных унаследованных классах.

В это случае возникают виртуальные методы. Они объявляются с ключевым словом `virtual` в базовом классе.

```C++
//класс предок
class Figure {
private:
	...
public:
	...
	virtual square() = 0;
}
//классы потомки
class Triangle : public Figure {
private:
	float a, b, c;
	...
public:
	...
	//реализация виртуального метода
	float square() {
		float p = (a + b + c) / 3;
		return (sqrtf(p*(p-a)*(p-b)*(p-c)));
	}
}
class Rectangle : public Figure {
private:
	float a, b;
	...
public:
	...
	//реализация виртуального метода
	float square() {
		return (a*b);
	}
}
```

Замечания по виртульным методам:

 * могут определяться в любой точке иерархии наследования;
 * класс с виртуальными методами называется абстрактным;
 * в иерархии наследования может быть много абстрактных классов;
 * создать экземпляр абстрактного класса нельзя, те если мы попытаемся сделать так, вы прилетит ошибка...
```C++
int main() {
	Figure obj;
	return 0;
}
``` 
Некоторые фишки, основанные на виртуальных методах:
 * `Интерфейс` -- абстрактный класс, у которого все методы виртуальный (задаёт, но не реализует, то, что должно быть);
 * `Реализация` -- какой-либо класс, унаследованный от интерфейса и реализующий все его виртуальные методы.

</details>

<details>
<summary><h3>6. Статические и дружественные поля и методы класса.</h3></summary>

`static` -- глобальная переменная/функция, внесённая в namespace класса.

Статическое поле класса:
 * привязано ко всех экземплярам класса сразу, никому из них лично не принадлежит;
 * при изменении (любым экземплярам класса или просто так) меняется для всех объектов сразу.

Статический метод класса:
 * привязан ко всех экземплярам класса сразу, вызывается вне контекста конкретного экземпляра (у него нет this);
 * может работать только с локальными переменными и статическими полями класса.

```C++
class A {
public:
	//нестатическое поле
	int non_static_int = 0;
	//статическое поле
	int static_int
	//статический метод
	static void static_method() {
		static_int++;		//можно
		non_static_int++;	//нельзя
	}
};
//Это объявление статического поля, без него будет ругаться линкер
int A::static_int = 0;

int main() {
	//Один экземпляр
	A a1;
	//ВТорой экземпляр
	A a2;
	//Обновляем статичекое поле класса через один из экземпляров
	a1.static_int = 7;
	//Обновляем статическое поле класса без использования экземпляров
	A::static_int = 8;
	//Вызываем статический метод
	// а) через экземпляры класса
	a1.static_method;
	a2.static_method;
	// б) без экземпляров класса
	A::static_method;
	return 0;
}
```

`friend` -- указание, кому всё-таки можно обращаться к приватным полям

```C++
class A {
	//Теперь класс B наш друг))))
	friend class B;
private:
	int secret;
public:
	A(int s) {
		secret = s;
	}
	void describe() {
		std::cout << "I'm A, my secret is " << secret << '\n';
	}
}
class B {
public:
	B() {}
	void run(A* a) {
		a->describe();
		std::cout << "I'm B, I know secret A: " << a->secret << '\n';
		//можно так же изменять значения дружественного класса
		a->secret--;
	}
}
```
`friend` -- исключение из правил, имеет доступ ко всему, включая private-поля. С одной стороны, нарушает всей строгой конструкции. С другой стороны, даёт возможностьне городить public для всех.
В примере, `class A` -- это друг `class B`, но не наоборот!!

</details>

<details>
<summary><h3>7. ООП и память. Правило трех.</h3></summary>

ООП и память??

<h4>Правило трёх</h4>

Если классу требуется пользовательский **деструктор**, пользовательский **конструктор копирования** или пользовательский **оператор присваивания копированием**, он почти наверняка требует все три.

Если один из них должен быть определен программистом, то это означает, что версия, сгенерированная компилятором, не удовлетворяет потребностям класса в одном случае и, вероятно, не удовлетворит в остальных случаях. Если же не реализовать какой-либо метод, то компилятор будет использовать базовые методы, идея которых может кардинально отличайться от нужд программиста. В результате может произойти следующее:

 - деструктор удалит не все используемыне ячейки в памяти, произойдёт утечка данных;
 - конструктор копирования выполняет "поверхностное копирование" (копирование данных без дублирования базового ресурса), в результате чего скопированный объект будет влаеть теми же ячейками в памяти, что и исходный объект;
 - оператор присваивания копированием так же буде выполнять поверхносное копирование.

</details>

<details>
<summary><h3>8. Схема сборки многофайловой программы – препроцессор, компилятор, линкер.</h3></summary>

1. **Препроцессор:** Обрабатывает директивы препроцессора (#include, #define).
2. **Компилятор:** Переводит код каждого исходного файла (.cpp) в объектный файл (.obj).
3. **Линкер:** Объединяет объектные файлы и библиотеки в исполняемый файл (.exe). 

</details>

<details>
<summary><h3>9. Системы контроля версий – классификация, зачем нужны. Git и Github – основы использования.</h3></summary>

</details>

<details>
<summary><h3>10. Стандарты С++. Какие есть, зачем нужны. Краткий обзор.</h3></summary>

</details>

<details>
<summary><h3>11. Контейнеры STL – какие есть, на каких структурах данных основаны, для чего применяются.</h3></summary>

</details>

<h2>Отл (продвинутые механики ООП и STL)</h2>
<details>
<summary><h3>1. Перегрузка операторов ввода-вывода, инкремента-декремента, присвоения и индексации</h3></summary>

-> операторы ввода-вывода

Перегрузка этих операторов используется в стандартной библиотеке для вставки объектов в текстовой поток и извлечения объектов из текстового потока (поэтому в этом качестве их еще называют оператором вставки в поток и оператором извлечения из потока). Перегружаются они всегда как свободные функции, их сигнатура подчиняется правилам: первый операнд является ссылкой на поток, второй операнд является ссылкой на вставляемый или извлекаемый объект, возвращаемое значение является ссылкой на поток. Вот пример.
```C++
#include <iostream>
struct Point {
    int X;
    int Y;
};
std::ostream& operator<<(std::ostream& strm, const Point& p) {
    strm << '[' << p.X << ',' << p.Y << ']';
    return strm;
}
```
Главная проблема этих перегрузок — довольно высокий приоритет операторов, поэтому скобками приходится пользоваться чаще, чем хотелось бы.

-> инеркмент/дикремент
  
Эти операторы являются частью стандартного интерфейса итератора. Префиксные формы являются унарными операторами, постфиксные бинарными с фиктивным вторым параметром целого типа. Обе они обычно реализуются как функции-члены и постфиксный вариант определяется через префиксный. Вот типичная реализация инкремента.
```C++
class Iter {
public:
    Iter& operator++() // префиксный инкремент
    {
        // реализация инкремента
        return *this;
    }

    const Iter operator++(int) // постфиксный инкремент
    {
        Iter it(*this);
        ++*this;
        return it;
    }
    // ...
};
```
Итераторы являются копируемыми типами без поддержки перемещения, поэтому постфиксный инкремент должен возвращать константный объект, это предотвращает модификацию возвращаемого значения.

В стандартной библиотеке инкремент перегружают все итераторы, а декремент двунаправленные итераторы и итераторы произвольного доступа.

-> присваивание
  
Оператор присваивания можно реализовать только, как функцию-член, которая должна иметь ровно один параметр. Тип этого параметра произвольный, соответственно, перегрузок может быть несколько, для разных типов параметра. Перегрузка оператора присваивания является составной частью поддержки семантики копирования/перемещения и к ней приходится прибегать достаточно часто. Оператор присваивания практически всегда идет в паре с конструктором, имеющим один параметр. Нормальная ситуация — это когда каждому конструктору с одним параметром прилагается соответствующий оператор присваивания. Если описать семантику присваивания «на пальцах», то присваивание должно полностью освободить все текущие ресурсы, которыми владеет объект (левый операнд), и на его месте создать новый объект, определяемый правым операндом.

Среди операторов присваивания выделяются два стандартных — оператор копирующего присваивания и оператор перемещающего присваивания, которые соответствуют копирующему конструктору и перемещающему конструктору.
```C++
class X {
public:
    X(const X& src);     // копирующий конструктор
    X(X&& src) noexcept; // перемещающий конструктор

    X& operator=X(const X& src);     // оператор копирующего присваивания
    X& operator=X(X&& src) noexcept; // оператор перемещающего присваивания
// ...
};
```
-> индексация

Этот бинарный оператор, который обычно называют индексатором, может быть реализован только, как функция-член, которая должна иметь ровно один параметр. Тип этого параметра произвольный, соответственно, перегрузок может быть несколько, для разных типов параметра. Индексатор обычно перегружается для «массивоподобных» типов, а также для других контейнеров, например ассоциативных массивов. Возвращаемое значение обычно является ссылкой на элемент контейнера. Также, в принципе, может быть возврат по значению, но следует иметь в виду, что при этом для получения адреса элемента нельзя будет использовать выражения `&х[i]`, допустимые для встроенного индексатора. Такое выражение не будет компилироваться, если возвращаемый тип встроенный, и будет давать адрес временного объекта для пользовательского возвращаемого типа.

Индексатор часто перегружают в двух вариантах — константном и неконстантном.
```C++
T& operator[](int ind);
const T& operator[](int ind) const;
```
Первая версия позволяет модифицировать элемент, вторая только прочитать и она будет выбрана для константных экземпляров и в константных функциях-членах.
</details>

<details>
<summary><h3>2. Шаблоны (templates) – что это такое, зачем нужны, к каким проблемам приводит их использование</h3></summary>

Шаблоны используются для обобщённого программирования. Вы пишете алгоритм, который работает с различными типами данных, требуя от них только некоторой небольшой функциональности, а компилятор при использовании этого шаблона с конкретным типом подставляет тип и фактически сам генерирует требуемый код на C++.

Вот простейший пример использования шаблонов:
```C++
template<typename T>
T min(const T x, const T y) {
    return x < y ? x : y;
}
```
Мы написали код, который работает с любым типом данных, требуя от этого типа только наличия операции "меньше" (operator<). (На самом деле ещё конструктора копирования, но это уже детали.) Теперь мы можем использовать наш шаблон:
```C++
int x, y;
int z = min(x,y);  // Автоматический вывод типа.
double a, b;
double c = min(a,b);  // Автоматический вывод типа.
double d = min<double>(x,y);  // Явное указание типа.

std::vector::iterator i, j, k;
k = min(i,j);
```
В этом мощь обобщённого программирования - код, написанный один раз используется многократно. Но есть и недостаток - "разбухание" бинарного кода - для каждого типа параметра шаблона компилятор создаст свой бинарный код.

Преимущества шаблонов:
* Мы можем использовать шаблоны для создания набора функций, которые применяют один и тот же алгоритм к разным типам данных;
* Некоторые вещи, которые кажутся тривиальными при использовании шаблонов (например, оператор равенства), очень сложно реализовать с помощью обычных методов OO, таких как наследование и полиморфизм;
* Поскольку их параметры известны во время компиляции, классы шаблонов более типизируемы и могут быть предпочтительнее структур кода, разрешаемых во время выполнения (таких как abstract классы). Существуют некоторые современные методы, которые могут значительно уменьшить объем кода при использовании шаблонов;
* Часто основная причина использования шаблонов в сочетании с STL - это может резко сократить время разработки.

Недостатки:
* Некоторые компиляторы плохо поддерживают шаблоны, поэтому использование шаблонов может снизить переносимость кода;
* Многим компиляторам не хватает четких инструкций при обнаружении ошибки определения шаблона;
* Поскольку компилятор генерирует дополнительный код для каждого типа шаблонов, беспорядочное использование шаблонов может привести к раздуванию кода, что приведет к увеличению размера исполняемых файлов;
* Поскольку шаблон по своей природе раскрывает свою реализацию, неразумное использование в больших системах может привести к увеличению времени сборки;
* Шаблоны находятся в заголовках, которые требуют полной перестройки всех частей проекта при внесении изменений.
</details>

<details>
<summary><h3>3. Исключения и умные указатели – что это такое, какие бывают, зачем нужны.</h3></summary>
-> Исключения

Исключения в программировании (exceptions) — это механизм, который позволяет программе обрабатывать нетипичную ситуацию и при этом не прекращать работу.

Исключения делятся на две большие группы, которые пересекаются друг с другом: синхронные и асинхронные. Синхронные могут возникнуть только в конкретном месте программы или при выполнении определенной операции: открытие файла, деление и так далее. Асинхронные могут возникнуть когда и где угодно.

Как происходит работа с исключениями:
* Разработчик пишет код и понимает, что в какой-то момент в том или ином месте может возникнуть нештатная ситуация;
* В этом месте пишется особый блок кода — обработчик. Он говорит программе: здесь может возникнуть особая ситуация, если она случится, выполни вот это;
* Внутри обработчика — функция, которая выполнится, если программа столкнется с описанной ситуацией.

**Обработка с возвратом и без возврата.** Эти виды обработки различаются реакцией на случившееся исключение. Версия с возвратом предполагает, что обработчик попытается разрешить проблему, а когда ему это удастся, вернет программу к исходному поведению. Обработка без возврата — вид обработки, когда проблема не ликвидируется, а участок кода, который не получается выполнить, пропускается.

**Структурная и неструктурная обработка.** Это два способа подключить обработчики. В первом случае они встраиваются в код, а когда генерируется исключение, для него выбирается тот или иной обработчик в зависимости от ситуации. Во втором случае обработчики существуют отдельно и «подключаются» к конкретным видам исключений с помощью специальных команд.

Пример:
```C++
void SomeFunction() {
    DoSomething0();
    try {
        SomeClass var;
        DoSomething1();
        DoSomething2();
        // ещё код
        cout << "Если возникло исключение, то этот текст не будет напечатан" << std::endl;
    }
    catch(ExceptionType e) {
        std::cout << "Поймано исключение: " << e.what() << std::endl;
        // ещё код
    }
    std::cout << "Это сообщение не будет выведено, если возникло исключение в DoSomething0 или " "непойманное исключение внутри блока try." << std::endl;
}
```

-> Умные указатели

Они обеспечивают автоматическое управление памятью: когда умный указатель больше не используется, то есть выходит из области видимости, память, на которую он указывает, автоматически высвобождается.

На самом деле это просто классы, которые оборачивают обычный указатель в свои недра и перегружают операторы -> и *. Благодаря этому трюку умный указатель имеет тот же синтаксис, что и обычный указатель. Когда умный указатель выходит из области видимости, срабатывает его деструктор и происходит очистка памяти.

В C++11 появилось три типа умных указателей, все они определены в заголовке из Стандартной библиотеки:
* std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом;
* std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет;
* std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик.

1. `std::unique_ptr` владеет объектом, на который он указывает, и никакие другие умные указатели не могут на него указывать. Когда std::unique_ptr выходит из области видимости, объект удаляется. Это полезно, когда вы работаете с временным, динамически выделенным ресурсом, который может быть уничтожен после выхода из области действия. 

Главная особенность этого умного указателя — исчезать, когда он больше не используется. Рассмотрим следующий код:
```C++
void compute() {
    std::unique_ptr<int[]> data = std::make_unique<int[]>(1024);
    /* выполнение некоторых значимых вычислений над вашими данными...*/
} // `data` выходит из области действия здесь: она автоматически уничтожается
int main() {
    compute();
}
```
**Один ресурс, один std::unique_ptr.** Я могу сказать, что `std::unique_ptr` очень ревниво относится к динамическому объекту, который он хранит: невозможно иметь несколько ссылок на его динамические данные. Например:
```C++
void compute(std::unique_ptr<int[]> p) { ... } 

int main() {
    std::unique_ptr<int[]> ptr = std::make_unique<int[]>(1024);
    std::unique_ptr<int[]> ptr_copy = ptr; // ОШИБКА! Копирование запрещено
    compute(ptr);  // ОШИБКА! `ptr` передается копией, а копирование не разрешено
}
```
2. `std::shared_ptr` владеет объектом, на который он указывает, но, в отличие от `std::unique_ptr`, он допускает множественные ссылки. Специальный внутренний счетчик уменьшается каждый раз, когда `std::shared_ptr`, указывающий на тот же ресурс, выходит из области видимости. Эта техника называется подсчетом ссылок. Когда последняя из них будет уничтожена, счетчик станет равным нулю, и данные будут высвобождены.

Умный указатель такого типа полезен, когда требуется обмениваться динамически распределенными данными, точно так же, как это делается с обычными указателями или ссылками. Например:
```C++
std::shared_ptr<int>    p1(new int);
std::shared_ptr<Object> p2(new Object("Lamp"));
```
Одна из главных особенностей std::shared_ptr — возможность отслеживать, сколько указателей ссылаются на один и тот же ресурс. Получить информацию о количестве ссылок можно с помощью метода use_count(). Рассмотрим следующее:
```C++
void compute() {
  std::shared_ptr<int> ptr = std::make_shared<int>(100);
  // ptr.use_count() == 1
  std::shared_ptr<int> ptr_copy = ptr;   // Сделать копию: с shared_ptr возможно!
  // ptr.use_count() == 2
  // ptr_copy.use_count() == 2, в конце концов, это одни и те же базовые данные.
} // Здесь `ptr` и `ptr_copy` выходят из области действия. Больше никаких ссылок  
  // исходные данные (т.е. use_count() == 0), поэтому они автоматически убираются.
int main() {
  compute();
}
```
**Один ресурс, много std::shared_ptr. Не забывайте о циклических ссылках!**
3. `std::weak_ptr` — это, по сути, `std::shared_ptr`, который не увеличивает счетчик ссылок. Он определяется как умный указатель, который содержит несобственную ссылку, или ослабленную ссылку, на объект, управляемый другим `std::shared_ptr`.

`std::weak_ptr` является своего рода инспектором для `std::shared_ptr` от которого он зависит. Вы должны сначала преобразовать его в `std::shared_ptr` с помощью метода `lock()` если вы действительно хотите работать с реальным объектом:
```C++
std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak(p_shared);
// ...
std::shared_ptr<int> p_shared_orig = p_weak.lock();
```
С помощью `std::weak_ptr` очень легко решить проблему висящих указателей — тех, которые указывают на уже удаленные данные. Он предоставляет метод `expired()`, который проверяет, был ли объект, на который ссылается ссылка, уже удален. Если `expired() == true`, исходный объект был где-то удален, и вы можете действовать соответствующим образом. Это то, что вы не можете сделать с необработанными указателями.
</details>

<details>
<summary><h3>4. Итераторы STL – что это такое и зачем нужны.</h3></summary>
Итераторы используются для указания адресов памяти контейнеров STL. В основном они используются в последовательностях чисел, символов и т.д. Они снижают сложность и время выполнения программы.

Операторы:
1. begin() - Эта функция используется для возврата начальной позиции контейнера;
2. end() - Эта функция используется для возврата заданного конечного положения контейнера;
3. advance() - Эта функция используется для увеличения позиции итератора до заданного числа, указанного в его аргументах;
4. next() - Эта функция возвращает новый итератор, на который итератор будет указывать после продвижения позиций, указанных в его аргументах;
5. prev() - Эта функция возвращает новый итератор, на который итератор будет указывать после уменьшения позиций, указанных в его аргументах;
6. inserter() - Эта функция используется для вставки элементов в любую позицию контейнера. Она принимает 2 аргумента: контейнер и итератор для определения местоположения, в которое должны быть вставлены элементы.
```C++
vector<int>::iterator ptr = ar.begin(); 
vector<int>::iterator ftr = ar.end();

// Using advance() to increment iterator position 
// points to 4 
advance(ptr, 3);

// Using next() to return new iterator 
// points to 4 
auto it = next(ptr, 3);

// Using next() to return new iterator 
// points to 4 
auto it = next(ptr, 3);

// copying 1 vector elements in other using inserter() 
// inserts ar1 after 3rd position in ar 
copy(ar1.begin(), ar1.end(), inserter(ar,ptr));
```
</details>

</details>
